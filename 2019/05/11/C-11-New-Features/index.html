<!DOCTYPE html>
<html lang="zh-Hans">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="Basic Features

Initializer List
Uniform Initialization
Auto Type
foreach
nullptr
enum class
static assert
delegating constructor
constexpr
New string">
    

    <!--Author-->
    
        <meta name="author" content="Xiaodong">
    

    <!-- Title -->
    
    <title>C++11 New Features | Wiki</title>

    <!-- Bootstrap Core CSS -->
    <link href="//cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/wiki/css/style.css">

    <!-- Custom Fonts -->
    <link href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Noto+Serif:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>

<body>

    <!-- Content -->
    <section class="article-container">
<!-- Back Home -->
<a class="nav-back" href="/wiki/">
    <i class="fa fa-puzzle-piece"></i>
</a>

<!-- Page Header -->
<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>C++11 New Features</h1>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Main Content -->
            <div class="post-content col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="tocStart">

</div>
<!-- toc -->
<ul>
<li><a href="#basic-features">Basic Features</a>
<ul>
<li><a href="#initializer-list">Initializer List</a></li>
<li><a href="#uniform-initialization">Uniform Initialization</a></li>
<li><a href="#auto-type">Auto Type</a></li>
<li><a href="#foreach">foreach</a></li>
<li><a href="#nullptr">nullptr</a></li>
<li><a href="#enum-class">enum class</a></li>
<li><a href="#static-assert">static assert</a></li>
<li><a href="#delegating-constructor">delegating constructor</a></li>
<li><a href="#constexpr">constexpr</a></li>
<li><a href="#new-string-literals">New string literals</a></li>
<li><a href="#keyword-final">Keyword final</a></li>
<li><a href="#keyword-delete">Keyword delete</a></li>
<li><a href="#keyword-default-for-default-constructor">Keyword default (for default constructor)</a></li>
<li><a href="#keyword-override">Keyword override</a></li>
<li><a href="#lambda-function">Lambda Function</a></li>
</ul></li>
<li><a href="#advanced-features">Advanced Features</a>
<ul>
<li><a href="#move-semantics">Move Semantics</a></li>
<li><a href="#perfect-forwarding">Perfect Forwarding</a></li>
<li><a href="#user-defined-literals">User defined literals</a></li>
<li><a href="#compiler-generated-functions">Compiler Generated Functions</a></li>
<li><a href="#shared-pointers">Shared Pointers</a></li>
<li><a href="#weak-pointers">Weak Pointers</a></li>
<li><a href="#unique-pointers">Unique Pointers</a></li>
</ul></li>
</ul>
<!-- tocstop -->
<div class="tocEnd">

</div>
<h2><span id="basic-features">Basic Features</span><a href="#basic-features" class="header-anchor">#</a></h2>
<h3><span id="initializer-list">Initializer List</span><a href="#initializer-list" class="header-anchor">#</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;; <span class="comment">// calling initializer_list constructor</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;; <span class="comment">// calling initializer_list constructor</span></span><br></pre></td></tr></table></figure>
<h3><span id="uniform-initialization">Uniform Initialization</span><a href="#uniform-initialization" class="header-anchor">#</a></h3>
<p>Three ordered choice of different constructors:</p>
<ol type="1">
<li><code>Initializer_list</code> constructor</li>
<li>Regular constructor that takes the appropriate parameters</li>
<li>Aggregate initializer</li>
</ol>
<h3><span id="auto-type">Auto Type</span><a href="#auto-type" class="header-anchor">#</a></h3>
<h3><span id="foreach">foreach</span><a href="#foreach" class="header-anchor">#</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : vec) &#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="nullptr">nullptr</span><a href="#nullptr" class="header-anchor">#</a></h3>
<h3><span id="enum-class">enum class</span><a href="#enum-class" class="header-anchor">#</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">apple</span> &#123;</span>green, red&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">orange</span> &#123;</span>big, small&#125;;</span><br><span class="line"></span><br><span class="line">apple a = green;</span><br><span class="line">orange b = big;</span><br><span class="line">a = b; <span class="comment">//error, they are different types</span></span><br></pre></td></tr></table></figure>
<h3><span id="static-assert">static assert</span><a href="#static-assert" class="header-anchor">#</a></h3>
<p>Do assertion in compilation process, rather than in the runtime.</p>
<h3><span id="delegating-constructor">delegating constructor</span><a href="#delegating-constructor" class="header-anchor">#</a></h3>
<p>Looks like one constructor inherits another constructor, the inherited constructor is executed first.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123; ... &#125;</span><br><span class="line">    A(some parameters) : A() &#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3><span id="constexpr">constexpr</span><a href="#constexpr" class="header-anchor">#</a></h3>
<p>If a return value of a function is defined as constexpr, it would be done during compilation.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">constexpr int square(int x) &#123; return x*x &#125;;</span><br><span class="line">int b = square(100);</span><br></pre></td></tr></table></figure>
<h3><span id="new-string-literals">New string literals</span><a href="#new-string-literals" class="header-anchor">#</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>        *a = <span class="string">u8"string"</span>; <span class="comment">//utf-8</span></span><br><span class="line"><span class="keyword">char16_t</span>    *b = <span class="string">u"string"</span>; <span class="comment">//utf-16</span></span><br><span class="line"><span class="keyword">char32_t</span>    *c = <span class="string">U"string"</span>; <span class="comment">//utf-32</span></span><br><span class="line"><span class="keyword">char</span>        *d = R<span class="string">"string \\"</span> <span class="comment">//raw string</span></span><br></pre></td></tr></table></figure>
<h3><span id="keyword-final">Keyword final</span><a href="#keyword-final" class="header-anchor">#</a></h3>
<p>Final virtual function cannot be overrided. <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dog</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> final</span>;<span class="comment">//this function cannot be overrided</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3><span id="keyword-delete">Keyword delete</span><a href="#keyword-delete" class="header-anchor">#</a></h3>
<p>Deleted functions cannot be used by objects. <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dog</span>&#123;</span></span><br><span class="line">    dog(<span class="keyword">int</span> age) &#123;&#125;</span><br><span class="line">    dog(dboule) = <span class="keyword">delete</span>; <span class="comment">//cannot use a double to generate an object of dog</span></span><br><span class="line">    dog&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> dog&amp;) = <span class="keyword">delete</span>; <span class="comment">//cannot assign an object to another</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3><span id="keyword-default-for-default-constructor">Keyword default (for default constructor)</span><a href="#keyword-default-for-default-constructor" class="header-anchor">#</a></h3>
<p>Force compiler to generate the default constructor. <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dog</span> &#123;</span></span><br><span class="line">    dog(<span class="keyword">int</span> age);</span><br><span class="line">    dog() = <span class="keyword">default</span>; <span class="comment">//default constructor</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3><span id="keyword-override">Keyword override</span><a href="#keyword-override" class="header-anchor">#</a></h3>
<h3><span id="lambda-function">Lambda Function</span><a href="#lambda-function" class="header-anchor">#</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x+y; &#125;(<span class="number">3</span>,<span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// output: 7</span></span><br><span class="line"><span class="keyword">auto</span> f = [] (<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x+y; &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f(<span class="number">3</span>,<span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> func&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">filter</span><span class="params">(func f, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f(i))</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    filter([] (<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> (x&gt;<span class="number">3</span>); v&#125;; <span class="comment">//output: 4 5 6</span></span><br><span class="line">    filter([] (<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> (x&gt;<span class="number">2</span> &amp;&amp; x&lt;<span class="number">5</span>); v&#125;; <span class="comment">//output: 3 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">4</span>;</span><br><span class="line">    filter([&amp;] (<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> (x&gt;y); &#125;, v); <span class="comment">//pass the local variable y to lambda function.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="advanced-features">Advanced Features</span><a href="#advanced-features" class="header-anchor">#</a></h2>
<h3><span id="move-semantics">Move Semantics</span><a href="#move-semantics" class="header-anchor">#</a></h3>
<p>Assume we have a function returns an object, then we pass the return value to another function, and we do not need this object any longer. In this case, we can create a move constructor for that class, which would save a lot of time for copying. <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp; i)</span> </span>&#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;  <span class="comment">//a is a lvalue</span></span><br><span class="line"><span class="keyword">int</span> &amp;b = a; <span class="comment">//b is a lvalue reference</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;c = b;<span class="comment">//c is a rvalue reference</span></span><br><span class="line"></span><br><span class="line">func(a); <span class="comment">//call the first function. cause a is a lvalue, the first func takes a lvalue reference which reference to a as an argument</span></span><br><span class="line">func(<span class="number">6</span>); <span class="comment">//call the second function. 6 is a rvalue. The second func takes a rvalue reference which reference to 6 as an argument</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//example 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVector</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">double</span>* arr_; <span class="comment">// a big array</span></span><br><span class="line"><span class="keyword">public</span>;</span><br><span class="line">    MyVector(<span class="keyword">const</span> MyVector&amp; rhs) &#123; <span class="comment">// copy constructor</span></span><br><span class="line">        size = rhs.size;</span><br><span class="line">        arr_ = <span class="keyword">new</span> <span class="keyword">double</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123; arr_[i] = rhs.arr_[i]; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MyVector(<span class="keyword">const</span> MyVector&amp;&amp; rhs) &#123; <span class="comment">//move constructor</span></span><br><span class="line">        size = rhs.size;</span><br><span class="line">        arr_ = rhs.arr_; <span class="comment">//it's much faster than copy constructor</span></span><br><span class="line">        rhs.arr_ = <span class="literal">nullptr</span>; <span class="comment">//we must set the original pointer to be nullptr, or the copied array would be deleted in deconstructor.</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~MyVector() &#123; <span class="keyword">delete</span> arr_; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(MyVector v)</span></span>;</span><br><span class="line"><span class="function">MyVector <span class="title">createMyVector</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Myvector vec = createMyVector();</span><br><span class="line">    foo(vec); <span class="comment">//if vec is no longer used after this line, which means we are gonna delete vec, we can use std::move instead of copy constructor</span></span><br><span class="line">    <span class="comment">// foo(std::move(vec));</span></span><br><span class="line">    <span class="comment">//move function turns the argument into an rvalue type.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3><span id="perfect-forwarding">Perfect Forwarding</span><a href="#perfect-forwarding" class="header-anchor">#</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">relay</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123; <span class="comment">//T&amp;&amp; is not necessary to be a rvalue reference</span></span><br><span class="line">    foo(<span class="built_in">std</span>::forward&lt;T&gt;(arg)); <span class="comment">//pass whatever arg is to foo. </span></span><br><span class="line">    <span class="comment">//what the forward function do is cast arg to T&amp;&amp; type</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">relay(<span class="number">6</span>); <span class="comment">//T = int&amp;&amp; =&gt; T&amp;&amp; = int&amp;&amp; &amp;&amp; = int&amp;&amp;  here T&amp;&amp; is a rvalue reference</span></span><br><span class="line">relay(x); <span class="comment">//T = int&amp; =&gt; T&amp;&amp; = int&amp; &amp;&amp; = int&amp;     here T&amp;&amp; is a lvalue reference</span></span><br></pre></td></tr></table></figure>
<h3><span id="user-defined-literals">User defined literals</span><a href="#user-defined-literals" class="header-anchor">#</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 99:</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> height = <span class="number">3.5</span>; <span class="comment">//meters? centimeters? inches?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C++11 user defined literals</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">long</span> <span class="keyword">double</span> <span class="keyword">operator</span><span class="string">""</span> _cm(<span class="keyword">long</span> <span class="keyword">double</span> x) &#123; <span class="keyword">return</span> x * <span class="number">10</span>; &#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">long</span> <span class="keyword">double</span> <span class="keyword">operator</span><span class="string">""</span> _m(<span class="keyword">long</span> <span class="keyword">double</span> x) &#123; <span class="keyword">return</span> x * <span class="number">1000</span>; &#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">long</span> <span class="keyword">double</span> <span class="keyword">operator</span><span class="string">""</span> _mm(<span class="keyword">long</span> <span class="keyword">double</span> x) &#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> height = <span class="number">3.4</span>_cm;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; height &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (height + <span class="number">13.0</span>_m) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>restriction on input types: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="keyword">const</span>*</span><br><span class="line">usigned <span class="keyword">long</span> <span class="keyword">long</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span>*, <span class="built_in">std</span>::<span class="keyword">size_t</span></span><br><span class="line"><span class="keyword">wchar_t</span> <span class="keyword">const</span>*, <span class="built_in">std</span>::<span class="keyword">size_t</span></span><br><span class="line"><span class="keyword">char16_t</span> <span class="keyword">const</span>*, <span class="built_in">std</span>::<span class="keyword">size_t</span></span><br><span class="line"><span class="keyword">char32_t</span> <span class="keyword">const</span>*, <span class="built_in">std</span>::<span class="keyword">size_t</span></span><br></pre></td></tr></table></figure></p>
<h3><span id="compiler-generated-functions">Compiler Generated Functions</span><a href="#compiler-generated-functions" class="header-anchor">#</a></h3>
<p>In C++ 03, compiler generates 4 functions for each class by default:</p>
<ol type="1">
<li>default constructor (generated only if no constructor is declared by user)</li>
<li>copy constructor (generated only if no 3,4,5,6 is declared by user)</li>
<li>copy assignment operator (generated only if no 2,4,5,6 is declared by user)</li>
<li>deconstructor</li>
</ol>
<p>In C++ 11, compiler generates extra 2 functions in addition to the above 4 functions:</p>
<ol start="5" type="1">
<li>move constructor (generated only if no 2,3,4,6 is declared by user)</li>
<li>move assignment operator (generated only if no 2,3,4,5 is declared by user)</li>
</ol>
<p>But there are some rules for compiler to determine if it needs to generator each one or not.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cow</span> &#123;</span> <span class="comment">// 1,2,4 (2 is deprecated)</span></span><br><span class="line">    Cow&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Cow&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span> <span class="comment">// 3,4</span></span><br><span class="line">    Cat(<span class="keyword">const</span> Cat&amp;) &#123;&#125; <span class="comment">// copy constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span> &#123;</span> <span class="comment">// 4</span></span><br><span class="line">    Duck(Duck&amp;&amp;) &#123;&#125; <span class="comment">// move constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frog</span> &#123;</span> <span class="comment">//4</span></span><br><span class="line">    Frog(Frog&amp;&amp;, <span class="keyword">int</span> = <span class="number">0</span>) &#123;&#125; <span class="comment">// move constructor</span></span><br><span class="line">    Frog(<span class="keyword">int</span> = <span class="number">0</span>) &#123;&#125; <span class="comment">// default constructor</span></span><br><span class="line">    Frog(<span class="keyword">const</span> Frog&amp;, <span class="keyword">int</span> = <span class="number">0</span>) &#123;&#125; <span class="comment">// copy constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span> &#123;</span> <span class="comment">//1,2,3</span></span><br><span class="line">    ~Fish() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3><span id="shared-pointers">Shared Pointers</span><a href="#shared-pointers" class="header-anchor">#</a></h3>
<p>With shared pointers, we do not need to care about where to delete a pointer, because shared pointer is used as a reference count. When the ref count reaches zero, the object is deleted.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line">    Dog(<span class="built_in">string</span> name) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Dog&gt; p(<span class="keyword">new</span> Dog(<span class="string">"gunner"</span>)); <span class="comment">//count = 1</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">shared_ptr</span>&lt;Dog&gt; p2 = p; <span class="comment">// count = 2</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p.use_count() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//here p2 is out of scope, so count is 1</span></span><br><span class="line">&#125; <span class="comment">// now p and p2 are out of scope, count is zero, object "gunner" is deleted</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//a better way to define a share pointer</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;Dog&gt; p = make_shared&lt;Dog&gt;(<span class="string">"tank"</span>);</span><br><span class="line"><span class="comment">//some cast functions can be used to cast smart pointers: static_pointer_cast, dynamic_pointer_cast, const_pointer_cast</span></span><br></pre></td></tr></table></figure>
<p>What if we created a shared pointer that points to an array of pointers? How would those object been freed?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Dog&gt; p1 = make_shared&lt;Dog&gt;(<span class="string">"gunner"</span>); </span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Dog&gt; p2 = <span class="built_in">shared_ptr</span>&lt;Dog&gt;(<span class="keyword">new</span> Dog(<span class="string">"tank"</span>), [](Dog* p) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"customed deleting"</span>; <span class="keyword">delete</span> p; &#125;</span><br><span class="line">    <span class="comment">//when p1 is out of scope, the object will be deleted by the default delete operation.</span></span><br><span class="line">    <span class="comment">//p2 will be deleted by the lambda function</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Dog&gt; p3(<span class="keyword">new</span> Dog[<span class="number">3</span>]); <span class="comment">// only p3 which points to the first object will be deleted </span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Dog&gt; p4(<span class="keyword">new</span> Dog[<span class="number">3</span>], [](Dog* p) &#123; <span class="keyword">delete</span>[] p; &#125; <span class="comment">//all objects will be deleted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="weak-pointers">Weak Pointers</span><a href="#weak-pointers" class="header-anchor">#</a></h3>
<p>Different from shared pointers, a weak pointer does not own the object it points to, which means it will not increase the reference count of that object.</p>
<p>We need weak pointer because some object may point to other objects, which may cause a <code>cyclic reference</code>. Then both of them will not be deleted becuase their reference count is always greater than 1.</p>
<p>That why weak pointer exists.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">weak_ptr&lt;Dog&gt; m_pFriend;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;Dog&gt; p = make_shared&lt;Dog&gt;(<span class="string">"gunner"</span>);</span><br><span class="line">m_pFriend = p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if we want to use the weak pointer, we should check if it's valid</span></span><br><span class="line"><span class="keyword">if</span> (!m_pFriend.expired()) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; m_pFriend.lock()-&gt;... &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Two important functions related to weak pointer: <code>expired</code>, <code>lock</code></p>
<h3><span id="unique-pointers">Unique Pointers</span><a href="#unique-pointers" class="header-anchor">#</a></h3>
<p>Unique pointer is different from shared pointer, the object it points to cannot be shared. As soon as the pointer is out of scope, or it points to another object, or points to <code>nullptr</code>, the object is freed.</p>
<p>Several useful funcstions:</p>
<ol type="1">
<li><code>release</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;Dog&gt; p(<span class="keyword">new</span> Dog(<span class="string">"gunner"</span>));</span><br><span class="line">Dog *p1 = p.release(); <span class="comment">//now p is not the ownner of gunner, it points to nullptr.</span></span><br><span class="line"><span class="comment">//we need to call delete to release the memory</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><code>reset</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//continue the code in previous</span></span><br><span class="line">p.reset(<span class="keyword">new</span> Dog(<span class="string">"tank"</span>)); <span class="comment">//gunner is deleted, p points to tank</span></span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><code>move</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;Dog&gt; p2(<span class="keyword">new</span> Dog(<span class="string">"tank"</span>));</span><br><span class="line">p2 = move(p); <span class="comment">//after this operation, p2 points to gunner, tank is deleted</span></span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>array pointers</li>
</ol>
<p>In shared pointers, we need to specify the delete function when creating an array of shared pointers. It's not necessary in creating unique pointers.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;Dog[]&gt; dogs(<span class="keyword">new</span> Dog[<span class="number">3</span>]);<span class="comment">//all three objects will be deleted</span></span><br></pre></td></tr></table></figure>
<p>TO BE CONTINUED...</p>

 
                <!-- Meta -->
                <div class="post-meta">
                    <hr>
                    <br>
                    <div class="post-tags">
                        
                    </div>
                    <div class="post-date">
                        05 / 11 / 2019
                    </div>
                </div>
            </div>

            <!-- Comments -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- Disqus Comments -->


            </div>
        </div>
    </div>
</article>
</section>

    <!-- Scripts -->
    <!-- jQuery -->
<script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script>
<!-- Bootstrap -->
<script src="//cdn.bootcss.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>


<script type="text/javascript">
	console.log('Hexo-theme-hollow designed by zchen9 ðŸ™‹ Â© 2015-' + (new Date()).getFullYear());
</script>

    <!-- Google Analytics -->
    

</body>

</html>